name: Release Please Guard

on:
  workflow_call:
    inputs:
      runner:
        description: 'Runner label'
        required: false
        default: 'ubuntu-latest'
        type: string
      main-branch:
        description: 'Default branch name'
        required: false
        default: 'main'
        type: string
      release-please-workflow:
        description: 'Workflow file to re-trigger after repair'
        required: false
        default: 'release-please.yml'
        type: string

jobs:
  heal-stale-release-state:
    runs-on: ${{ inputs.runner }}
    timeout-minutes: 15
    concurrency:
      group: release-please-guard
      cancel-in-progress: false
    permissions:
      actions: write
      contents: write
      pull-requests: write
    steps:
      - name: Repair stale merged release PRs
        env:
          GH_TOKEN: ${{ github.token }}
          MAIN_BRANCH: ${{ inputs.main-branch }}
          RELEASE_PLEASE_WORKFLOW: ${{ inputs.release-please-workflow }}
        run: |
          set -euo pipefail

          repo="${GITHUB_REPOSITORY}"
          stale_prs="$(gh pr list --repo "${repo}" --state merged \
            --search 'head:release-please--branches--main label:"autorelease: pending"' \
            --json number,mergeCommit,mergedAt,title,url --limit 20)"
          stale_count="$(echo "${stale_prs}" | jq 'length')"
          echo "Found ${stale_count} stale merged release PR(s)."

          if [ "${stale_count}" -eq 0 ]; then
            exit 0
          fi

          create_release_for_tag() {
            local tag="$1"
            local target_sha="$2"
            local pr_number="$3"

            if gh release view "${tag}" --repo "${repo}" >/dev/null 2>&1; then
              echo "Release ${tag} already exists."
              return
            fi

            gh release create "${tag}" \
              --repo "${repo}" \
              --target "${target_sha}" \
              --title "${tag}" \
              --notes "Backfilled missing release for merged release PR #${pr_number} via Release Please Guard."
            echo "Created missing release ${tag}."
          }

          # Derive the tag name from a release-please manifest path and version.
          # Convention: "." -> "v{version}", other paths -> "{basename}-v{version}".
          tag_for_path() {
            local path="$1"
            local version="$2"
            if [ "${path}" = "." ]; then
              echo "v${version}"
            else
              echo "$(basename "${path}")-v${version}"
            fi
          }

          repaired_any=0

          while IFS=$'\t' read -r pr_number merge_sha merged_at; do
            if [ -z "${merge_sha}" ] || [ "${merge_sha}" = "null" ]; then
              echo "Skipping PR #${pr_number}: missing merge commit."
              continue
            fi

            if [ -n "${merged_at}" ]; then
              merged_epoch="$(date -u -d "${merged_at}" +%s || true)"
              now_epoch="$(date -u +%s)"
              if [ -n "${merged_epoch}" ] && [ "$((now_epoch - merged_epoch))" -lt 1200 ]; then
                echo "Skipping PR #${pr_number}: merged recently; waiting for normal release flow."
                continue
              fi
            fi

            parent_sha="$(gh api "repos/${repo}/commits/${merge_sha}" --jq '.parents[0].sha')"

            old_manifest_b64="$(mktemp)"
            new_manifest_b64="$(mktemp)"
            old_manifest_file="$(mktemp)"
            new_manifest_file="$(mktemp)"

            if gh api "repos/${repo}/contents/.release-please-manifest.json?ref=${parent_sha}" \
                --jq '.content' > "${old_manifest_b64}" 2>/dev/null; then
              tr -d '\n' < "${old_manifest_b64}" | base64 -d > "${old_manifest_file}"
            else
              echo '{}' > "${old_manifest_file}"
            fi

            if gh api "repos/${repo}/contents/.release-please-manifest.json?ref=${merge_sha}" \
                --jq '.content' > "${new_manifest_b64}" 2>/dev/null; then
              tr -d '\n' < "${new_manifest_b64}" | base64 -d > "${new_manifest_file}"
            else
              echo '{}' > "${new_manifest_file}"
            fi

            # Find all paths whose version changed between parent and merge commits.
            mapfile -t expected_tags < <(
              jq -r -n \
                --slurpfile old "${old_manifest_file}" \
                --slurpfile new "${new_manifest_file}" '
                ($old[0] // {}) as $o |
                ($new[0] // {}) as $n |
                [($n | keys[]) as $k
                  | select(($o[$k] // "") != $n[$k])
                  | {path: $k, version: $n[$k]}]
                | .[]
                | "\(.path)\t\(.version)"
              '
            )

            rm -f "${old_manifest_file}" "${new_manifest_file}" "${old_manifest_b64}" "${new_manifest_b64}"

            if [ "${#expected_tags[@]}" -eq 0 ]; then
              echo "No manifest delta detected for PR #${pr_number}; removing stale pending label."
            else
              for entry in "${expected_tags[@]}"; do
                path="$(echo "${entry}" | cut -f1)"
                version="$(echo "${entry}" | cut -f2)"
                tag="$(tag_for_path "${path}" "${version}")"
                create_release_for_tag "${tag}" "${merge_sha}" "${pr_number}"
              done
            fi

            gh pr edit "${pr_number}" --repo "${repo}" --remove-label "autorelease: pending" || true
            echo "Removed autorelease: pending from PR #${pr_number}."
            repaired_any=1
          done < <(echo "${stale_prs}" | jq -r '.[] | "\(.number)\t\(.mergeCommit.oid // "null")\t\(.mergedAt // "")"')

          if [ "${repaired_any}" -eq 1 ]; then
            gh workflow run "${RELEASE_PLEASE_WORKFLOW}" --repo "${repo}" --ref "${MAIN_BRANCH}"
            echo "Triggered ${RELEASE_PLEASE_WORKFLOW} after stale-state repair."
          else
            echo "No eligible stale release PR required repair."
          fi
